# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать.
Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя     
>`db.currentOp({"active": true, "secs_running":{"$gt": 5}});`     
И убить этот процесс:     
`db.killOp(opid)`     
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB
> Вопрос очень широкий, сначала нужно разобраться с причинами, нужно выяснить, какие именно запросы зависают, в этом поможет та же команда    
>`db.currentOp({"active": true, "secs_running":{"$gt": 5}});`     
> Затем нужно разбираться с этими конктретными запросами при помощи метода `explain`.   

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?
> ~~Проблема, возможно, в том, что размер TTL недостаточно мал и память переполняется быстрее, чем реплицируется (если можно так сказать).~~       
> Возможно, проблема вызвана неправильно выбранной политикой вытеснения Redis (maxmemory-policy).
 
## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

> Это происходит когда запускается длинный или сложный запрос MySQL. Возможные решения проблемы - увеличить в глобальных настройках время ожидания ответа соединения до одной минуты (по умолчанию 10 сек):          
> `SET GLOBAL connect_timeout = 60;`     
> Но в целом, нужно выяснить, какие именно запросы выполняются долго и попытаться оптимизировать БД теми методами, которые мы изучили. Причину замедления можно узнать с помощью `slow_log`, для этого нужно вкючить эту опцию в конфигурации mysqld и сделать рестарт.     
> Из своего опыта (Django ORM) могу сказать, что прежде всего нужно попытаться оптимизировать сами запросы, а затем уже думать, как оптимизировать собственно БД или увеличивать время запроса, выделять дополнительные ресурсы и т.п.

## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?
> Это означает, что PostgreSQL пытается потребить больше памяти, чем есть в ОС. В этом случае процесс "убивается" и СУБД становится недоступной. 

Как бы вы решили данную проблему?
> ~~В Linux 2.6 и более поздних версиях можно изменить поведение ядра, чтобы оно не «передавало» память при помощи параметра `vm.overcommit_memory`. Он не предотвратит вызов убийцы OOM в целом, он значительно снизит вероятность и, следовательно, приведет к более надежному поведению системы. Для этого этот параметр нужно установить равным 2 в режиме строгой перезагрузки:    
> `sysctl -w vm.overcommit_memory = 2`    
> или изменив соответственно файл:     
> `/etc/sysctl.conf`~~      
> ~~В любом случае, очевидно, что проблема в нехватке памяти. Это означает, чтобы процесс не убивался oom killer'ом, нужно ограничить аппетиты PostgreSQL по потреблению памяти.~~     


> ~В статье, которуе вы рекомендовали, сказано, что в случае удаления процесса PostgreSQL oom киллером необходимо проверить настройку памяти в соответствии с нашим оборудованием.~         
>   
_набор параметров, которые нужно крутить:_
> - shared_buffers;
> - max_connections и work_mem;
> - maintenance_work_mem;
> - effective_cache_size;
> - huge_pages и vacuum_cost_delay;
> - temp_buffers;
> - max_prepared_transactions;



---

### Как cдавать задание

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---
